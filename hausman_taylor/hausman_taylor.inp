set verbose off

function matrix wald_test (const bundle b)
   matrix Wald = {}
   scalar x2 = qform(b.coeff[2:,]', invpd(b.vcv[2:,2:]))
   if ok(x2)
      scalar df = b.ncoeff - 1
      Wald = zeros(1,3)
      Wald[1] = x2
      Wald[2] = df
      Wald[3] = pvalue(X, df, x2)
   endif
   return Wald
end function

function matrix hausman_test (matrix *bfe,
                              matrix *bht,
                              matrix *Vfe,
                              matrix *Vht,
                              int oid)
   matrix Htest = {}
   matrix bdiff = (bfe - bht)'
   catch scalar H = qform(bdiff, ginv(Vfe - Vht))
   if $error == 0 && H > 0
      Htest = zeros(1,3)
      Htest[1] = H
      Htest[2] = oid
      Htest[3] = pvalue(X, oid, H)
   endif
   return Htest
end function

function scalar calculate_Tbar (series *Ti,
                                scalar effn)
   # find the harmonic mean of the Ti's
   matrix mTi = pshrink(Ti)
   return effn / sumc(1 ./ mTi)
end function

function bundle split_lists (const list Lexo,
                             const list Lndo,
                             int verbosity)
   list X1
   list X2
   list Z1
   list Z2

   loop i=1..nelem(Lexo) -q
      if max(psd(Lexo[i])) > 0
         X1 += Lexo[i]
      else
         Z1 += Lexo[i]
      endif
   endloop

   loop i=1..nelem(Lndo) -q
      if max(psd(Lndo[i])) > 0
         X2 += Lndo[i]
      else
         Z2 += Lndo[i]
      endif
   endloop

   oid = nelem(X1) - nelem(Z2)

   if verbosity > 0
      printf "\nTime-varying\n"
      printf " exogenous: "
      list X1 print
      printf " endogenous: "
      list X2 print
      printf "Time-invariant\n"
      printf " exogenous: "
      list Z1 print
      printf " endogenous: "
      list Z2 print
      printf "\nOver-identification rank: %d\n", oid
      if verbosity == 1
         printf "\n"
      endif
   endif

   if oid < 0
      funcerr "X1 must have at least as many members as Z2"
   endif
   if nelem(X1 && X2) > 0
      funcerr "X1 and X2 cannot have members in common"
   endif
   if nelem(Z1 && Z2) > 0
      funcerr "Z1 and Z2 cannot have members in common"
   endif

   return _(X1, X2, Z1, Z2, oid)
end function

function bundle hausman_taylor (series y "dependent variable",
                                list Lexo "exogenous regressors",
                                list Lndo "endogenous regressors",
                                int verbosity[0:2:1],
                                bool as_stata[0])
   bundle b
   b.depvar = argname(y)

   # ensure that Lexo and Lndo do not contain const
   Lexo -= const
   Lndo -= const
   # and record in bundle
   list b.Lexo = Lexo
   list b.Lndo = Lndo

   # determine and enforce the usable sample
   list tmp = y Lexo Lndo
   series all_ok = ok(tmp)
   if min(all_ok) == 0
      y = all_ok ? y : NA
   endif

   bundle hl = split_lists(Lexo, Lndo, verbosity)
   scalar oid = hl.oid
   list X = hl.X1 hl.X2
   list Z = hl.Z1 hl.Z2

   # H-T step 1: fixed effects to get sigma^2_e
   panel y 0 X -q
   matrix bfe = $coeff
   if verbosity > 1
      printf "\nHausman-Taylor step 1: fixed effects\n"
      printf "dependent variable y, %d observations\n", $T
      matrix cmat = bfe ~ $stderr
      strings pnames = varnames($xlist)
      modprint cmat pnames
   endif
   scalar k = $ncoeff
   list cX = const X
   series eit = pmean(y - lincomb(cX, bfe))
   eit = all_ok ? eit : NA
   bfe = bfe[2:k]
   matrix Vfe = $vcv[2:k,2:k]
   scalar Tmin = $["Tmin"]
   scalar Tmax = $["Tmax"]
   scalar effn = $["n_included_units"]

   # calculate variance Ã  la Stata
   scalar s2e = $ess / ($T - effn)

   # H-T step 2: auxiliary IV estimation
   set warnings off
   tsls eit 0 Z ; 0 Lexo -q --no-tests
   if verbosity > 1
      printf "Hausman-Taylor step 2: auxiliary IV\n"
      printf "dependent variable eit, %d observations\n", $T
      matrix cmat = $coeff ~ $stderr
      strings pnames = varnames($xlist)
      modprint cmat pnames
   endif
   # again, in agreement with Stata
   scalar s2star = $ess / effn

   scalar theta = 0
   series s_theta
   scalar vartheta = 0

   if Tmax == Tmin
      # balanced: theta is a scalar
      scalar s2u = (s2star - s2e) / Tmax
      if s2u < 0
         s2u = 0
      else
         theta = 1 - sqrt(s2e / (s2e + Tmax*s2u))
      endif
   else
      # unbalanced: calculate theta per unit
      series Ti = ok(y) ? pnobs(y) : NA
      scalar Tbar = calculate_Tbar(&Ti, effn)
      scalar s2u = (s2star - s2e) / Tbar
      if s2u < 0
         s2u = 0
      else
         s_theta = 1 - sqrt(s2e / (s2e + Ti*s2u))
         vartheta = 1
      endif
   endif

   # record theta in bundle
   b.theta = vartheta ? mean(s_theta) : theta

   # transformed dep. var. and constant
   if vartheta
      series gy = y - s_theta * pmean(y)
      series gcons = 1 - s_theta
   else
      series gy = y - theta * pmean(y)
      series gcons = 1 - theta
   endif

   # gX = quasi-demeaned X
   string vname
   list gX = null
   loop foreach i X
      vname = sprintf("gx_%s", varname(X[i]))
      if vartheta
         gX += genseries(vname, X[i] - s_theta * pmean(X[i], all_ok))
      else
         gX += genseries(vname, X[i] - theta * pmean(X[i], all_ok))
      endif
   endloop

   # gZ = quasi-demeaned Z
   list gZ = null
   loop foreach i Z
      vname = sprintf("gz_%s", varname(Z[i]))
      if vartheta
         gZ += genseries(vname, (1 - s_theta) * Z[i])
      else
         gZ += genseries(vname, (1 - theta) * Z[i])
      endif
   endloop

   # the transformed instruments, W
   list W = empty
   # include quasi-demeaned X1?
   if s2u > 0 && Tmax > Tmin && !as_stata
      list X1 = hl.X1
      loop foreach i X1
         W += gx_$i
      endloop
   endif

   # demeaned X1 and X2
   loop foreach i X -q
      vname = sprintf("dm_%s", varname(X[i]))
      W += genseries(vname, X[i] - pmean(X[i], all_ok))
   endloop

   # plus plain X1 and Z1 (exog)
   W += hl.X1 hl.Z1
   list tmp = const X Z
   strings parnames = varnames(tmp)

   # H-T final step: IV estimation on GLS-transformed data.
   # To replicate R's plm substitute "const" for "gcons"
   # among the instruments.
   if $version >= 20261 # FIXME
      tsls gy gcons gX gZ ; gcons W -q --no-tests="hausman"
   else
      tsls gy gcons gX gZ ; gcons W -q
   endif
   matrix bht = $coeff[2:k]
   matrix Vht = $vcv[2:k,2:k]

   b.coeff = $coeff
   b.ncoeff = $ncoeff
   b.stderr = $stderr
   b.vcv = $vcv
   b.nobs = $T
   b.Tmin = Tmin
   b.Tmax = Tmax
   b.effn = effn
   b.parnames = parnames
   b.s_e = sqrt(s2e)
   b.s_u = sqrt(s2u)
   list b.xlist = const X Z
   series b.yhat = lincomb(b.xlist, b.coeff)
   series b.uhat = y - b.yhat
   scalar b.rsq = corr(y, b.yhat)^2

   matrix Wald = wald_test(b)
   if cols(Wald) > 0
      b.Wald = Wald
   endif
   matrix Htest = hausman_test(&bfe, &bht, &Vfe, &Vht, oid)
   if cols(Htest) > 0
      b.Htest = Htest
   endif
   if oid > 0
      # grab Sargan test from tsls estimation
      catch matrix Stest = $sargan
      if $error == 0
         b.Stest = Stest
      endif
   endif
   if verbosity > 0
      ht_print(&b)
   endif
   return b
end function

function void ht_print (bundle *b)
   strings parnames = b.parnames
   scalar unbal = b.Tmin != b.Tmax
   if strlen(b.depvar) > 0
      printf "Hausman-Taylor estimates for %s\n", b.depvar
   else
      printf "\nHausman-Taylor estimates\n"
   endif
   printf "using %d observations (n = %d, ", b.nobs, b.effn
   if unbal
      printf "Tmin = %d, Tmax = %d)\n", b.Tmin, b.Tmax
   else
      printf "T = %d)\n", b.Tmin
   endif
   printf "endogenous: "
   list endo = b.Lndo
   list endo print
   matrix B = b.coeff ~ b.stderr
   modprint B parnames
   printf "  sigma_u = %#.8g\n", b.s_u
   printf "  sigma_e = %#.8g\n", b.s_e
   printf "  theta   = %#.8g", b.theta
   if unbal && b.theta > 0
      printf " (average)\n\n"
   else
      printf "\n\n"
   endif
   scalar ntests = 0
   if inbundle(b, "Wald")
      ntests++
      matrix Wald = b.Wald
      printf "Wald overall test: chi-square(%d) = %#g [%.4f]\n",
      Wald[2], Wald[1], Wald[3]
   endif
   if inbundle(b, "Htest")
      ntests++
      matrix Htest = b.Htest
      printf "Hausman test: chi-square(%d) = %#g [%.4f]\n",
      Htest[2], Htest[1], Htest[3]
   endif
   if inbundle(b, "Stest")
      ntests++
      matrix Stest = b.Stest
      printf "Sargan test:  chi-square(%d) = %#g [%.4f]\n",
      Stest[2], Stest[1], Stest[3]
   endif
   if ntests > 0
      printf "\n"
   endif
end function

function bundle ht_uimaker (void)
   bundle ret
   ret.Lexo = _(list_exclude="y")
   ret.Lndo = _(list_exclude="y")
   return ret
end function

function bundle GUI_hausman_taylor (series y "dependent variable",
                                    list Lexo "exogenous regressors",
                                    list Lndo "endogenous regressors",
                                    bool verbose[0],
                                    bool as_stata[0])
   string depvar = argname(y, "y")
   if depvar != "y"
      genseries(depvar, y)
   endif
   scalar verbo = verbose ? 2 : 1
   return hausman_taylor(@depvar, Lexo, Lndo, verbo, as_stata)
end function
